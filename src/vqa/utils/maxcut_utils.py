import random
from typing import Any, Callable, Dict, List, Optional, Tuple, Union

import algorithmx
import networkx as nx
import numpy as np
from beartype import beartype


def get_maxcut_costs(graph) -> np.ndarray:
    """Returns the MaxCut cost values of a graph

    Returns:
        numpy.ndarray: The cost values as an 1D-array
    """

    def product(*args, repeat=1):
        # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
        # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
        pools = [list(pool) for pool in args] * repeat
        result = [[]]
        for pool in pools:
            result = [x + [y] for x in result for y in pool]
        for prod in result:
            yield list(prod)

    # Number of edges
    M = graph.number_of_edges()
    # Number of nodes
    N = graph.number_of_nodes()
    # Adjacency matrix
    A = nx.adjacency_matrix(graph).todense()

    # Generate a list of all possible nâ€tuples of elements from {1,-1} and
    # organize them as a (2^n x n) matrix. In other words create all
    # possible solutions to the problem.
    s = np.array(list(product([1, -1], repeat=N)))

    # Construct the the cost function for Max Cut: C=1/2*Sum(Z_i*Z_j)-M/2
    # Note: This is the minimization version
    return 1 / 2 * (np.diag(s @ np.triu(A) @ s.T) - M)


def get_maxcut_graph(n: int, seed: int) -> nx.DiGraph():
    """Generate an instance of a maxcut graph

    Args:
        n (int): Number of nodes in the graph.

    Returns:
        nx.DsGraph: A networkx graph instance.
    """
    random.seed(seed)
    G = nx.dense_gnm_random_graph(n=n, m=random.randint(n, n * (n - 1) / 2), seed=seed)
    # G = nx.dense_gnm_random_graph(n=n, m=random.randint(7, 8), seed=seed)
    for (u, v) in G.edges():
        G.edges[u, v]["weight"] = 1  # random.randint(0,10)
    return G


def visualize_maxcut_graph(G: nx.Graph, solution: Any = None) -> Any:
    """Visualize the maxcut graph via algorithmx.

    Args:
        G (nx.DiGraph): The graph obtained from the networkx library.
        solution (np.ndarray, optional): The solution bitstring for a given cut.
          Defaults to None.

    Returns:
        canvas (algorithmx.jupyter_canvas()): The canvas generated by the
          algorithmx library
    """
    if not isinstance(G, nx.Graph):
        raise TypeError(
            "Graph is not a networkx class (found type: %s)" % type(G).__name__
        )

    canvas = algorithmx.jupyter_canvas()

    canvas.nodes(G.nodes).add()
    canvas.edges(G.edges).add().label().add().text(lambda e: G.edges[e]["weight"])

    if type(solution) is not type(None):
        for n in G.nodes:
            if solution[n] == 1:
                canvas.node(n).color("red")

        for (u, v) in G.edges():
            if solution[u] != solution[v]:
                canvas.edge((u, v)).traverse("red")
    return canvas
